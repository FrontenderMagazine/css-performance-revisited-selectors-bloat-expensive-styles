# Пересмотрим вопрос CSS-производительности: селекторы, раздутый код и дорогие стили

*Что такое быстрый CSS? Какие у него слабые места? Работают ли всё ещё правила 
быстрых и медленных селекторов? Являются ли используемые нами свойства более 
влиятельными чем селекторы? Думаю время пересмотреть некоторые из этих вопросов.*

Если смотреть на всю картину в целом, когда нужно ускорить работу 
вебсайта/веб-приложения, по приоритетности оптимизация CSS определённо занимает 
далеко не первое место. Существует множество других способов оптимизации, 
которые приносят больше результата, причём быстрее. Однако если внести небольшие 
улучшения во все составляющие сайта, в том числе CSS, вместе они окажутся не 
такими уж небольшими; пользователь будет только в выигрыше.

Обмениваясь соображениями насчёт относительной «скорости» CSS, разработчики 
часто упоминают работу [Стива Саундерса (Steve Souders)][1] по CSS-селекторах от 
2009 года. Её используют в качестве подтверждения заявлений вроде «селекторы по 
атрибуту являются медленными» или «псевдоселекторы медленные».

По крайней мере последние парочку лет мне кажется, что такие вещи уже не должны 
вызывать беспокойства. Я не устаю повторять следующую фразу:

> Когда дело касается CSS, архитектура заключена вне скобок; а 
производительность — внутри

> [Бен Фрейн (Ben Frain)][2]

Однако максимум на что я был способен до этих пор — это в подтверждение своих 
догадок, что селекторы не так уж значимы, ссылаться [на статью Николь Саливан 
(Nicole Sullivan) на сайте Performance Calendar][3]. Сам я эту теорию не 
проверял: нехватка таланта и далекий от аналитики мозг не дали мне попытаться 
это сделать.

Мой мозг остался всё таким же, однако сейчас я легче восприму возможные насмешки 
по поводу моих попыток, если это позволит обменяться информацией с кем-то, 
имеющим больше опыта или данных на эту тему. Так что я решил провести несколько 
примитивных тестов.

## Проверка скорости селекторов

В ранее упомянутых тестах Стива Саундерса используется JavaScript-конструктор 
`new Date()`. Однако в наше время современные браузеры (за исключением 
iOS/Safari) поддерживают API временных характеристик навигации (Navigation 
Timing API), который даёт нам более точные инструменты для измерения. Я буду 
применять его следующим образом:

    <script type="text/javascript">
        ;(function TimeThisMother() {
            window.onload = function(){
                setTimeout(function(){
                var t = performance.timing;
                    alert("Speed of selection is: " + (t.loadEventEnd — t.responseEnd) + " milliseconds");
                }, 0);
            };
        })();
    </script>

Это позволяет нам установить временной срок между моментом получения всех 
ресурсов (`responseEnd`) и моментом отображения страницы (`loadEventEnd`).

Я подготовил очень простой тест. 20 разных страниц, все с идентичным огромным 
деревом документа, состоящим из 1000 одинаковых кусков этой разметки:

    <div class="tagDiv wrap1">
      <div class="tagDiv layer1" data-div="layer1">
        <div class="tagDiv layer2">
          <ul class="tagUl">
            <li class="tagLi"><b class="tagB"><a href="/" class="tagA link" data-select="link">Select</a></b></li>
          </ul>
        </div>
      </div>
    </div>

Отличие каждой страницы состоит только в правиле, которое применяется для 
выделения самого внутреннего узла в блоках. 20 разных вариантов селекторов были 
испробованы для окраски внутреннего узла в красный цвет:

1. [Атрибут `data`][4]
2. [Атрибут `data` (с указанием элемента)][5]
3. [Атрибут `data` (без указания элемента, но с конкретным значением)][6]
4. [Атрибут `data` (с указанием элемента и конкретным значением)][7]
5. [Несколько атрибутов `data` (с указанием элементов и конкретными значениями)][8]
6. [Один псевдоэлемент в селекторе (например `:after`)][9]
7. [Комбинирование классов (например `class1.class2`)][10]
8. [Несколько классов][11]
9. [Несколько классов с дочерним селектором][12]
10. [Частичное совпадение по атрибуту (например [class^=“wrap”])][13]
11. [Селектор `nth-child`][14]
12. [Селектор `nth-child`, за которым следует ещё один селектор `nth-child`][15]
13. [Бредовая выборка (указана вся иерархия выборки, каждый класс в цепочке, 
например div.wrapper > div.tagDiv > div.tagDiv.layer2 > ul.tagUL > li.tagLi > 
b.tagB > a.TagA.link)][16]
14. [Полубредовая выборка (например .tagLi .tagB a.TagA.link)][17]
15. [Универсальный селектор][18]
16. [Селектор по элементу][19]
17. [Контекстный селектор][20]
18. [Контекстный селектор из трёх элементов][21]
19. [Контекстный селектор с псевдоэлементом][22]
20. [Селектор по классу][23]

Тест был запущен 5 раз в каждом браузере и результаты были сведены к среднему 
значению. Использовались современные браузеры:

* Chrome 34.0.1838.2 dev
* Firefox 29.0a2 Aurora
* Opera 19.0.1326.63
* Internet Explorer 9.0.8112.16421
* Android 4.2 (планшет, 7")

Чтобы пролить немного света на то, как ведёт себя популярный браузер без частых 
обновлений как в других браузерах, была использована более ранняя версия 
Internet Explorer (а не самая последняя).

Хотите провести те же тесты самостоятельно? Получить доступ к файлам можно по 
этой ссылке на GitHub: [https://github.com/benfrain/css-performance-tests][24]. 
Просто откройте каждую страницу в выбранном вами браузере (помните, что для 
вывода результата браузер должен поддерживать API временных характеристик 
навигации). Также вам следует знать, что выполняя тесты я проигнорировал парочку 
первых результатов, так как для некоторых браузеров они оказывались невероятно 
высоки.

Оценивая результаты, не думаю, что сравнение показателей в разных браузерах о 
чем-либо расскажет. Не в этом цель тестов. Их цель только попытаться оценить 
относительную разницу в скорости работы разных применённых селекторов. Поэтому 
логичнее смотреть на таблицу вниз по колонкам, а не по рядам. 

Вот результаты. Все временные значения указаны в миллисекундах:

<table>
<tr>
<td>Тест</td>
<td>Chrome 34</td>
<td>Firefox 29</td>
<td>Opera 19</td>
<td>IE9</td>
<td>Android 4</td>
</tr>
<tr>
<td>1</td>
<td>56.8</td>
<td>125.4</td>
<td>63.6</td>
<td>152.6</td>
<td>1455.2</td>
</tr>
<tr>
<td>2</td>
<td>55.4</td>
<td>128.4</td>
<td>61.4</td>
<td>141</td>
<td>1404.6</td>
</tr>
<tr>
<td>3</td>
<td>55</td>
<td>125.6</td>
<td>61.8</td>
<td>152.4</td>
<td>1363.4</td>
</tr>
<tr>
<td>4</td>
<td>54.8</td>
<td>129</td>
<td>63.2</td>
<td>147.4</td>
<td>1421.2</td>
</tr>
<tr>
<td>5</td>
<td>55.4</td>
<td>124.4</td>
<td>63.2</td>
<td>147.4</td>
<td>1411.2</td>
</tr>
<tr>
<td>6</td>
<td>60.6</td>
<td>138</td>
<td>58.4</td>
<td>162</td>
<td>1500.4</td>
</tr>
<tr>
<td>7</td>
<td>51.2</td>
<td>126.6</td>
<td>56.8</td>
<td>147.8</td>
<td>1453.8</td>
</tr>
<tr>
<td>8</td>
<td>48.8</td>
<td>127.4</td>
<td>56.2</td>
<td>150.2</td>
<td>1398.8</td>
</tr>
<tr>
<td>9</td>
<td>48.8</td>
<td>127.4</td>
<td>55.8</td>
<td>154.6</td>
<td>1348.4</td>
</tr>
<tr>
<td>10</td>
<td>52.2</td>
<td>129.4</td>
<td>58</td>
<td>172</td>
<td>1420.2</td>
</tr>
<tr>
<td>11</td>
<td>49</td>
<td>127.4</td>
<td>56.6</td>
<td>148.4</td>
<td>1352</td>
</tr>
<tr>
<td>12</td>
<td>50.6</td>
<td>127.2</td>
<td>58.4</td>
<td>146.2</td>
<td>1377.6</td>
</tr>
<tr>
<td>13</td>
<td>64.6</td>
<td>129.2</td>
<td>72.4</td>
<td>152.8</td>
<td>1461.2</td>
</tr>
<tr>
<td>14</td>
<td>50.2</td>
<td>129.8</td>
<td>54.8</td>
<td>154.6</td>
<td>1381.2</td>
</tr>
<tr>
<td>15</td>
<td>50</td>
<td>126.2</td>
<td>56.8</td>
<td>154.8</td>
<td>1351.6</td>
</tr>
<tr>
<td>16</td>
<td>49.2</td>
<td>127.6</td>
<td>56</td>
<td>149.2</td>
<td>1379.2</td>
</tr>
<tr>
<td>17</td>
<td>50.4</td>
<td>132.4</td>
<td>55</td>
<td>157.6</td>
<td>1386</td>
</tr>
<tr>
<td>18</td>
<td>49.2</td>
<td>128.8</td>
<td>58.6</td>
<td>154.2</td>
<td>1380.6</td>
</tr>
<tr>
<td>19</td>
<td>48.6</td>
<td>132.4</td>
<td>54.8</td>
<td>148.4</td>
<td>1349.6</td>
</tr>
<tr>
<td>20</td>
<td>50.4</td>
<td>128</td>
<td>55</td>
<td>149.8</td>
<td>1393.8</td>
</tr>
<tr>
<td>Наибольшая разница</td>
<td>16</td>
<td>13.6</td>
<td>17.6</td>
<td>31</td>
<td>152</td>
</tr>
<tr>
<td>Самый медленный</td>
<td>13</td>
<td>6</td>
<td>13</td>
<td>10</td>
<td>6</td>
</tr>
</table>
 
## Разница между самым быстрым и самым медленным селектором

Колонка «Наибольшая разница» показывает разницу в миллисекундах между самым 
быстрым и самым медленным селектором. На фоне браузеров для настольных 
компьютеров, IE9 выделяется наибольшей разницей между самым быстрым и самым 
медленным селектором, составляющей 31мс. В остальных разница составляет примерно 
половину от этой цифры. Однако, что интересно, согласие насчёт того какой 
селектор является самым медленным, достигнуто не было.

## Самый медленный селектор

Мне показалось любопытным то, что самыми медленными были признаны разные типы 
селекторов в зависимости от браузера. Opera и Chrome признали, что труднее всего 
обработке поддается «бредовый» селектор (тест 13). Солидарность Opera и Chrome в 
этом вопросе пожалуй не удивительна, так как они построены на одном движке blink. 
Firefox наибольшие усилия пришлось приложить для селектора по псевдоэлементу 
([тест 6][25]), та же история с устройством с Android 4.2 (7" планшет hudl от 
Tesco). Ахиллесовой пятой Internet Explorer 9 оказался селектор с частичным 
совпадением по атрибуту ([тест 10][26]).

## Правильный подход к архитектуре CSS

Одно можно определить точно: использование селекторов на основе классов с 
простой иерархией даёт не только более модульный и менее специализированный код, 
что позволяет его использовать многократно, но также предоставляет селекторы, 
которые являются более быстрыми, чем любые другие (да, селекторы по ID наверняка 
работали бы быстрее, но мне, например, не нравится идея создания большой кодовой 
базы на основе селекторов по ID).

### Что это значит?

Для меня результаты тестов стали подтверждением моей уверенности в том, что 
волноваться по поводу типа выбранного селектора абсолютно глупо. Сомнения в 
правильности типа селектора бессмысленны, так как мы видим явные различия в том, 
как обработчики селекторов работают в зависимости от типа селектора. Более того, 
разница между самым быстрым и самым медленным селектором не существенна, даже 
при таком немыслимо-огромном размере дерева документа. Как говорят у нас на 
севере Англии: «Есть рыбка для жарки и покрупнее».

После написания этой статьи со мной связался Бенджамин Пулейн (Benjamin Poulain), 
инженер WebKit, и высказал свои опасения по поводу используемой методологии. Его 
комментарии были очень интересными и с его разрешения я привожу некоторые из них 
ниже:

«Измеряя производительность на основе загрузки страницы, ты измеряешь большое 
количество факторов, значительно более существенных чем CSS, производительность 
CSS является очень незначительной  составляющей, которая влияет на загрузку 
страницы:

Если взять временной график для `[class^="wrap"]` в качестве примера (взят на 
старом WebKit, немного похожий на Chrome), мы увидим:

~10% времени потрачено на прорисовку. ~21% времени — на первичную разметку. ~48% 
времени потрачено на синтаксический разбор и построение дерева документа. ~8% — 
на определение стиля, ~5% — на сбор данных о стиле — это то, что мы должны 
протестировать и что должно занимать большую часть времени. (Остальные временные 
затраты распределяются на множество небольших функций).

В случае с предложенным выше тестом, представим, что у нас есть базовый 
показатель в 100 мс с самым быстрым селектором. Из них 5 мс уходит на сбор 
данных о стилях. Если другой селектор является в три раза более медленным, 
загрузка страницы займёт 110мс. Тест должен давать в результате разницу в 300%, 
а мы получаем только 10%.»

На этом этапе я ответил, что если я понимаю доводы Бенджамина правильно, мой 
тест доказывает, что одна и та же страница, если все параметры сохранены 
одинаковыми, отображается по большому счёту за одно и то же время, вне 
зависимости от использованного селектора. Некоторое время спустя Бенджамин 
ответил более подробно:

«Я полностью согласен, что предварительная оптимизация селекторов бессмысленна, 
но по абсолютно другим причинам:

Предусмотреть конечное влияние конкретного селектора на производительность путём 
простого изучения селекторов практически невозможно. В процессе обработки 
селекторы перестраиваются, разделяются, собираются и компилируются. Чтобы 
предугадать конечную производительность конкретных селекторов, нужно точно знать 
в каких условиях они были собраны, как они были скомпилированы и, наконец, как 
выглядит дерево документа. 

Это всё очень сильно отличается в зависимости от движка, что делает весь процесс 
ещё более непредсказуемым.

Второй аргумент почему я против оптимизации селекторов веб-разработчиками 
состоит в том, что вероятней всего в результате они сделают только хуже. 
Количество дезинформации о селекторах превышает количество достоверных 
кросс-браузерных данных. Шансы, что кто-то сделает всё как надо, довольно малы. 

На практике люди обнаруживают наличие проблемы производительности, порождённой 
CSS, и начинают удалять правило за правилом, пока проблема не исчезнет. Я считаю, 
что это правильный подход, который к тому же является более простым и приводит к 
желаемому результату.»

## Причина и следствие

Если количество элементов на странице уменьшить наполовину, как и следует 
ожидать, время затраченное на выполнение любого теста уменьшится соразмерно. 
Однако избавление от части дерева документа не всегда возможно. Это привело меня 
к размышлениям о том, как на результаты повлияет разница в количестве 
неиспользуемых стилей CSS.

## Как на быстроту применения селекторов повлияет большое количество неиспользуемых стилей?

[Ещё один тест][27]: я взял большую таблицу стилей с fiat.co.uk. Она состояла из 
около 3000 строчек CSS. Все эти неприменяемые стили были добавлены перед 
последним правилом, которое выбирало внутренний узел `a.link` и делало его 
красным. Я провёл такое же сведение результатов к среднему после 5 запусков 
теста в каждом браузере как и в прошлый раз.

Затем я [удалил половину этих правил и повторил тест][28] для сравнения. Вот 
результаты:

<table>
<tr>
<td>Тест</td>
<td>Chrome 34</td>
<td>Firefox 29</td>
<td>Opera 19</td>
<td>IE9</td>
<td>Android 4</td>
</tr>
<tr>
<td>Полная загрузка</td>
<td>64.4</td>
<td>237.6</td>
<td>74.2</td>
<td>436.8</td>
<td>1714.6</td>
</tr>
<tr>
<td>Половина загрузки</td>
<td>51.6</td>
<td>142.8</td>
<td>65.4</td>
<td>358.6</td>
<td>1412.4</td>
</tr>
</table>

## Стилевая диета

Получены довольно интересные показатели. Например, Firefox выполнила этот тест в 
1.7 раз медленнее чем тест с самым медленным селектором (тест 6). Android 4.3 
потратил в 1.2 больше времени чем на тест с самым медленным селектором (тест 6). 
Internet Explorer выполнил этот тест в целых 2,5 раза медленнее чем тест с самым 
медленным селектором!

Как видите, все показатели для Firefox существенно уменьшились, когда половина 
стилей была удалена (примерно 1500 строчек). Устройство с Android также 
практически приблизилось к скорости теста с самым медленным селектором.

### Удаление неиспользуемых стилей

Вам этот ужасный сценарий кажется знакомым? Огромные CSS-файлы со всевозможными 
селекторами (часто с такими, которые вообще не работают), масса нереально 
специфических селекторов на 7 и больше уровней глубиной, неприменимые префиксы, 
наобум натыканные идентификаторы и размеры файлов в 50-80Кб (и больше).

Если вы работаете над кодовой базой с большим CSS-файлом такого рода, когда 
никто точно не может сказать для чего собственно все эти стили, перед 
применением селекторов проведите оптимизацию CSS.

От первоочередной оптимизации CSS пользы будет больше, чем от придирчивого 
выбора используемых селекторов. Она принесёт двойной результат: меньше кода, 
который пользователю нужно скачать и меньше кода для обработки агентом 
пользователя — скачок скорости гарантирован, как ни крути.

Впрочем, это не повлияет на реальную производительность вашего CSS.

## Производительность внутри скобок

[Последний тест][29], проведённый мной, обрушивал на страницу кучу «дорогих» 
свойств и значений.

    .link {
        background-color: red;
        border-radius: 5px;
        padding: 3px;
        box-shadow: 0 5px 5px #000;
        -webkit-transform: rotate(10deg);
        -moz-transform: rotate(10deg);
        -ms-transform: rotate(10deg);
        transform: rotate(10deg);
        display: block;
    }

При применении такого правила были получены следующие результаты:

<table>
<tr>
<td>Тест</td>
<td>Chrome 34</td>
<td>Firefox 29</td>
<td>Opera 19</td>
<td>IE9</td>
<td>Android 4</td>
</tr>
<tr>
<td>Дорогие стили</td>
<td>65.2</td>
<td>151.4</td>
<td>65.2</td>
<td>259.2</td>
<td>1923</td>
</tr>
</table>

Здесь хотя бы все браузеры достигли скорости как в тесте с самым медленным 
селектором (у IE скорость была в 1,5 раза меньше чем в тесте с самым медленным 
селектором (10) и устройство с Android справилось в 1,3 раза медленнее, чем с 
самым медленным селектором (тест 6)), однако это ещё не полная картина. 
Попробуйте прокрутить страницу! Перерисовка страницы с такими стилями доведёт 
ваш компьютер до слёз.

Свойства, которые мы поместили внутрь скобок — вот что действительно напрягает 
систему. Очевидно, что прокручивание страницы предполагает бесконечные дорогие 
перерисовки и изменения в макете, что не может не увеличить нагрузку на 
устройство. У вас хороший экран с высоким разрешением? Всё будет ещё хуже когда 
центральный и графический процессор попытаются уложиться с перерисовкой на 
экране в 16 мс.

При проведении теста на дорогие стили на MacBook Pro с 15" экраном ретина, время 
отрисовки в режиме постоянной отрисовки в Chrome не опускалось ниже 280мс 
(помните, мы стремимся к 16мс и ниже). Для сравнения, для первой тестовой 
страницы с селекторами оно не поднималось выше 2,5 мс. И это не опечатка. Эти 
свойства привели к 112-кратному возрастанию времени отрисовки. Вот такие вот 
дорогие свойства. 

## Какие свойства являются дорогими?

«Дорогая» пара свойство/значение — это та, которая практически наверняка создаст 
для браузера дополнительные трудности, когда ему придётся перерисовать страницу 
(например, при прокрутке).

Как знать какой стиль окажется «дорогим»? К счастью, в этом случае можно 
применить здравый смысл и довольно точно догадаться что приведёт к 
дополнительной нагрузке на браузер. Всё, что предполагает выполнение браузером 
корректировок/перерасчётов перед отрисовкой страницы, будет стоить больших 
затрат. Например, `box-shadow`, `border-radius`, прозрачность (так как браузеру 
нужно рассчитать что должно быть отображено под ней), трансформации и убийцы 
производительности — CSS-фильтры; если производительность является для вас 
приоритетной, все свойства такого рода — ваши злейшие враги.

Ещё в 2012 году Юрий Зайцев под ником «kangax» написал [замечательный пост в 
блоге также посвящённый производительности CSS][30]. Он использовал различные 
инструменты разработчика для измерения производительности. Он провёл отличную 
работу и показал как различные свойства по-разному влияют на производительность. 
Если вас интересует информация такого рода, этот пост явно стоит вашего времени.

## Заключение

Вот мои выводы из этого небольшого эпизода: корпеть над селекторами, 
используемыми в современных браузерах бессмысленно; большинство методов выбора 
теперь работают так быстро, что на это не стоит тратить время. Более того, у 
браузеров итак не прослеживается единое мнение о том, какие селекторы являются 
медленными. Когда вам нужно ускорить CSS, это то на что следует обратить 
внимание в последнюю очередь. — чрезмерное количество неиспользуемых стилей 
скорее всего обойдётся вам дороже в плане производительности, чем любые 
селекторы, это второй момент на который нужно обратить внимание. 3000 строчек на 
странице, которые не используются или являются лишними — это не такое уж редкое 
явление. Хотя часто принято сваливать все стили в один громадный `styles.css`, 
если для разных разделов вашего сайта/веб-приложения можно добавить разные 
(дополнительные) таблицы стилей (в стиле графа зависимостей), это может быть 
лучшим решением. Если в ваш CSS за всё время вносили изменения несколько 
разработчиков, обратитесь к инструментам вроде [UnCSS][31] для автоматического 
удаления стилей — делать это вручную сомнительное удовольствие! — битва за 
высокопроизводительный CSS не будет выиграна за счёт используемых селекторов, 
она будет выиграна с помощью рассудительного использования свойств и значений — 
быстрая отрисовка чего-либо на странице конечно важна, но не менее важно то, 
насколько быстрой кажется работа страницы при взаимодействии с пользователем. В 
первую очередь обратите внимание на наличие дорогих пар свойств/значений (здесь 
вам пригодится режим постоянной отрисовки в Chrome), они скорее всего принесут 
наиболее весомый результат.

[1]: http://stevesouders.com/
[2]: http://benfrain.com/
[3]: http://calendar.perfplanet.com/2011/css-selector-performance-has-changed-for-the-better/
[4]: http://benfrain.com/selector-test/01.html
[5]: http://benfrain.com/selector-test/02.html
[6]: http://benfrain.com/selector-test/03.html
[7]: http://benfrain.com/selector-test/04.html
[8]: http://benfrain.com/selector-test/05.html
[9]: http://benfrain.com/selector-test/06.html
[10]: http://benfrain.com/selector-test/07.html
[11]: http://benfrain.com/selector-test/08.html
[12]: http://benfrain.com/selector-test/09.html
[13]: http://benfrain.com/selector-test/10.html
[14]: http://benfrain.com/selector-test/11.html
[15]: http://benfrain.com/selector-test/12.html
[16]: http://benfrain.com/selector-test/13.html
[17]: http://benfrain.com/selector-test/14.html
[18]: http://benfrain.com/selector-test/15.html
[19]: http://benfrain.com/selector-test/16.html
[20]: http://benfrain.com/selector-test/17.html
[21]: http://benfrain.com/selector-test/18.html
[22]: http://benfrain.com/selector-test/19.html
[23]: http://benfrain.com/selector-test/20.html
[24]: https://github.com/benfrain/css-performance-tests
[25]: http://benfrain.com/selector-test/06.html
[26]: http://benfrain.com/selector-test/10.html
[27]: http://benfrain.com/selector-test/2-01.html
[28]: http://benfrain.com/selector-test/2-02.html
[29]: http://benfrain.com/selector-test/3-01.html
[30]: http://perfectionkills.com/profiling-css-for-fun-and-profit-optimization-notes/
[31]: https://github.com/giakki/uncss